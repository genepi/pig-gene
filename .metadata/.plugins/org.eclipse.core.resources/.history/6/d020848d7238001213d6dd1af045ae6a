package pigGene;

import static org.apache.pig.builtin.PigStorage.parser;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Properties;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.hadoop.mapreduce.InputFormat;
import org.apache.hadoop.mapreduce.Job;
import org.apache.pig.ResourceSchema;
import org.apache.pig.builtin.PigStorage;
import org.apache.pig.impl.logicalLayer.schema.Schema;
import org.apache.pig.impl.logicalLayer.schema.Schema.FieldSchema;
import org.apache.pig.impl.util.StorageUtil;
import org.apache.pig.impl.util.UDFContext;

public class PigGeneStorageUnmerged extends PigStorage {
	private final Options validOptions = new Options();
	private static final String TAG_SOURCE_PATH = "tagsource";
	private byte fieldDel = '\t';
	private final CommandLine configuredOptions;
	static ResourceSchema schema;

	static {
		final ArrayList<FieldSchema> fieldSchemaList = new ArrayList<FieldSchema>();
		fieldSchemaList.add(new FieldSchema("chrom", org.apache.pig.data.DataType.CHARARRAY));
		fieldSchemaList.add(new FieldSchema("pos", org.apache.pig.data.DataType.LONG));
		fieldSchemaList.add(new FieldSchema("id", org.apache.pig.data.DataType.CHARARRAY));
		fieldSchemaList.add(new FieldSchema("ref", org.apache.pig.data.DataType.CHARARRAY));
		fieldSchemaList.add(new FieldSchema("alt", org.apache.pig.data.DataType.CHARARRAY));
		fieldSchemaList.add(new FieldSchema("qual", org.apache.pig.data.DataType.DOUBLE));
		fieldSchemaList.add(new FieldSchema("filt", org.apache.pig.data.DataType.CHARARRAY));
		fieldSchemaList.add(new FieldSchema("info", org.apache.pig.data.DataType.CHARARRAY));
		fieldSchemaList.add(new FieldSchema("format", org.apache.pig.data.DataType.CHARARRAY));
		fieldSchemaList.add(new FieldSchema("genotype", org.apache.pig.data.DataType.CHARARRAY));
		// fieldSchemaList.add(new FieldSchema("file",
		// org.apache.pig.data.DataType.CHARARRAY));
		schema = new ResourceSchema(new Schema(fieldSchemaList));
	}

	public PigGeneStorageUnmerged() {
		this("\t", "");
	}

	public PigGeneStorageUnmerged(String delimiter) {
		this(delimiter, "");
	}

	public PigGeneStorageUnmerged(String delimiter, String options) {
		populateValidOptions();
		fieldDel = StorageUtil.parseFieldDel(delimiter);
		String[] optsArr = options.split(" ");
		try {
			configuredOptions = parser.parse(validOptions, optsArr);
			isSchemaOn = configuredOptions.hasOption("schema");
			dontLoadSchema = configuredOptions.hasOption("noschema");
			tagSource = configuredOptions.hasOption(TAG_SOURCE_PATH);
		} catch (ParseException e) {
			HelpFormatter formatter = new HelpFormatter();
			formatter.printHelp("PigStorage(',', '[options]')", validOptions);
			// We wrap this exception in a Runtime exception so that
			// existing loaders that extend PigStorage don't break
			throw new RuntimeException(e);
		}
	}

	private void populateValidOptions() {
		validOptions.addOption("schema", false, "Loads / Stores the schema of the relation using a hidden JSON file.");
		validOptions.addOption("noschema", false, "Disable attempting to load data schema from the filesystem.");
		validOptions.addOption(TAG_SOURCE_PATH, false, "Appends input source file path to end of each tuple. Make sure to set pig.splitCombination to false");
	}

	@SuppressWarnings("rawtypes")
	@Override
	public InputFormat getInputFormat() {
		return new PigGeneInputFormatUnmerged();
	}

	@Override
	public ResourceSchema getSchema(final String location, final Job job) throws IOException {
		final Properties p = UDFContext.getUDFContext().getUDFProperties(this.getClass(), new String[] { signature });
		p.setProperty(signature + ".schema", schema.toString());
		return schema;
	}

}